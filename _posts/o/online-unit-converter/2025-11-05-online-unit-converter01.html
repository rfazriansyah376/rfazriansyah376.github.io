---
layout: post02
title: "Automating Jekyll Content Updates with GitHub Actions and Liquid Data"
categories: [jekyll,github-pages,liquid,automation,workflow,jamstack,static-site,ci-cd,content-management,online-unit-converter]
tags: [jekyll,github,liquid,automation,workflow,actions]
description: "Discover how to automate Jekyll content updates using GitHub Actions and Liquid data files for a smarter, maintenance-free static site workflow."
---

<p>As your static site grows, managing and updating content manually becomes time-consuming. Whether you run a blog, documentation hub, or resource library built with Jekyll, small repetitive tasks like updating metadata, syncing data files, or refreshing pages can drain productivity. Fortunately, GitHub Actions combined with Liquid data structures can automate much of this process — allowing your Jekyll site to stay current with minimal effort.</p>

<h2>Why Automate Jekyll Content Updates</h2>
<p>Automation is one of the greatest strengths of the JAMstack. Since Jekyll sites are tightly integrated with GitHub, you can use continuous integration (CI) to perform actions automatically whenever content changes. This means that instead of manually building and deploying, you can have your site:</p>
<ul>
  <li>Rebuild and deploy automatically on every commit.</li>
  <li>Sync or generate data-driven pages from structured files.</li>
  <li>Fetch and update external data on a schedule.</li>
  <li>Manage content contributions from multiple collaborators safely.</li>
</ul>
<p>By combining GitHub Actions with Liquid data, your Jekyll workflow becomes both dynamic and self-updating — a key advantage for long-term maintenance.</p>

<h2>Understanding the Role of Liquid Data Files</h2>
<p>Liquid data files in Jekyll (located inside the <code>_data</code> directory) act as small databases that feed your site’s content dynamically. They can store structured data such as lists of team members, product catalogs, or event schedules. Instead of hardcoding content directly in markdown or HTML files, you can manage data in YAML, JSON, or CSV formats and render them dynamically using Liquid loops and filters.</p>

<h3>Basic Data File Example</h3>
<p>Suppose you have a data file <code>_data/resources.yml</code> containing:</p>
<pre><code>- title: JAMstack Guide
  url: https://jamstack.org
  category: documentation
- title: Liquid Template Reference
  url: https://shopify.github.io/liquid/
  category: reference</code></pre>

<p>You can loop through this data in your layout or page using Liquid:</p>
<pre><code>{% for item in site.data.resources %}
  &lt;li&gt;&lt;a href="{{ item.url }}"&gt;{{ item.title }}&lt;/a&gt; - {{ item.category }}&lt;/li&gt;
{% endfor %}</code></pre>

<p>Now imagine this data file updating automatically — new entries fetched from an external source, new tags added, and the page rebuilt — all without editing any markdown file manually. That’s the goal of automation.</p>

<h2>How GitHub Actions Fits into the Workflow</h2>
<p>GitHub Actions provides a flexible automation layer for any GitHub repository. It lets you trigger workflows when specific events occur (like commits or pull requests) or at scheduled intervals (e.g., daily). Combined with Jekyll, you can automate tasks such as:</p>
<ul>
  <li>Fetching data from external APIs and updating <code>_data</code> files.</li>
  <li>Rebuilding the Jekyll site and deploying to GitHub Pages automatically.</li>
  <li>Generating new posts or pages based on templates.</li>
</ul>

<h3>Basic Automation Workflow Example</h3>
<p>Here’s a sample GitHub Actions configuration to rebuild your site daily and deploy it automatically:</p>
<pre><code>name: Scheduled Jekyll Build
on:
  schedule:
    - cron: '0 3 * * *' # Run every day at 3AM UTC
jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1
      - name: Install dependencies
        run: bundle install
      - name: Build site
        run: bundle exec jekyll build
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./_site</code></pre>

<p>This ensures your Jekyll site automatically refreshes, even if no manual edits occur — great for sites pulling external data or using automated content feeds.</p>

<h2>Dynamic Data Updating via GitHub Actions</h2>
<p>One powerful use of automation is fetching external data and writing it into Jekyll’s <code>_data</code> folder. This allows your site to stay up-to-date with third-party content, API responses, or public data sources.</p>

<h3>Fetching External API Data</h3>
<p>Let’s say you want to pull the latest GitHub repositories from your organization into a <code>_data/repos.json</code> file. You can use a small script and a GitHub Action to automate this:</p>

<pre><code>name: Fetch GitHub Repositories
on:
  schedule:
    - cron: '0 4 * * *'
jobs:
  update-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Fetch GitHub Repos
        run: |
          curl https://api.github.com/orgs/your-org/repos?per_page=10 &gt; _data/repos.json
      - name: Commit and push data changes
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add _data/repos.json
          git commit -m "Auto-update repository data"
          git push</code></pre>

<p>Each day, this Action will update your <code>_data/repos.json</code> file automatically. When the site rebuilds, Liquid loops render fresh repository data — providing real-time updates on a static website.</p>

<h2>Using Liquid to Render Updated Data</h2>
<p>Once the updated data is committed, Jekyll automatically includes it during the next build. You can display it in any layout or page using Liquid loops, just like static data. For example:</p>
<pre><code>{% for repo in site.data.repos %}
  &lt;div class="repo"&gt;
    &lt;h3&gt;&lt;a href="{{ repo.html_url }}"&gt;{{ repo.name }}&lt;/a&gt;&lt;/h3&gt;
    &lt;p&gt;{{ repo.description | default: "No description available." }}&lt;/p&gt;
  &lt;/div&gt;
{% endfor %}</code></pre>
<p>This transforms your static Jekyll site into a living portal that stays synchronized with external services automatically.</p>

<h2>Combining Scheduled Automation with Manual Triggers</h2>
<p>Sometimes you want a mix of automation and control. GitHub Actions supports both. You can run workflows on a schedule and also trigger them manually from the GitHub web interface using the <code>workflow_dispatch</code> event:</p>
<pre><code>on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'</code></pre>
<p>This gives you the flexibility to trigger an update whenever you push new data or want to refresh content manually.</p>

<h2>Organizing Your Repository for Automation</h2>
<p>To make automation efficient and clean, structure your repository properly:</p>
<ul>
  <li><strong>_data/</strong> – for structured YAML, JSON, or CSV files.</li>
  <li><strong>_scripts/</strong> – for custom fetch or update scripts (optional).</li>
  <li><strong>.github/workflows/</strong> – for all GitHub Action files.</li>
</ul>
<p>Keeping each function isolated ensures that your automation scales well as your site grows.</p>

<h2>Example Workflow Comparison</h2>
<p>The following table compares a manual Jekyll content update process with an automated GitHub Action workflow.</p>

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>Manual Process</th>
      <th>Automated Process</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Updating data files</td>
      <td>Edit YAML or JSON manually</td>
      <td>Auto-fetch via GitHub API</td>
    </tr>
    <tr>
      <td>Rebuilding site</td>
      <td>Run build locally</td>
      <td>Triggered automatically on schedule</td>
    </tr>
    <tr>
      <td>Deploying updates</td>
      <td>Push manually to Pages branch</td>
      <td>Deploy automatically via CI/CD</td>
    </tr>
  </tbody>
</table>

<h2>Practical Use Cases</h2>
<p>Here are a few real-world applications for Jekyll automation workflows:</p>
<ul>
  <li><strong>News aggregator:</strong> Fetch daily headlines via API and update <code>_data/news.json</code>.</li>
  <li><strong>Community site:</strong> Sync GitHub issues or discussions as blog entries.</li>
  <li><strong>Documentation portal:</strong> Pull and publish updates from multiple repositories.</li>
  <li><strong>Pricing or product pages:</strong> Sync product listings from a JSON API feed.</li>
</ul>

<h2>Benefits of Automated Jekyll Content Workflows</h2>
<p>By combining Liquid’s rendering flexibility with GitHub Actions’ automation power, you gain several long-term benefits:</p>
<ul>
  <li><strong>Reduced maintenance:</strong> No need to manually edit files for small content changes.</li>
  <li><strong>Data freshness:</strong> Automated updates ensure your site never shows outdated content.</li>
  <li><strong>Version control:</strong> Every update is tracked, auditable, and reversible.</li>
  <li><strong>Scalability:</strong> The more your site grows, the less manual work required.</li>
</ul>

<h2>Final Thoughts</h2>
<p>Automation is the key to maintaining an efficient JAMstack workflow. With GitHub Actions handling updates and Liquid data files powering dynamic rendering, your Jekyll site can stay fresh, fast, and accurate — even without human intervention. By setting up smart automation workflows, you transform your static site into an intelligent system that updates itself, saving hours of manual effort while ensuring consistent performance and accuracy.</p>

<h2>Next Steps</h2>
<p>Start by identifying which parts of your Jekyll site rely on manual updates — such as blog indexes, API data, or navigation lists. Then, automate one of them using GitHub Actions. Once that works, expand your automation to handle content synchronization, build triggers, and deployment. Over time, you’ll have a fully autonomous static site that operates like a dynamic CMS — but with the simplicity, speed, and reliability of Jekyll and GitHub Pages.</p>
