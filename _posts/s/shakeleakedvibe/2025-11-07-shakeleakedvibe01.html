---
layout: post02
title: "Building Data Driven Random Posts with JSON and Lazy Loading in Jekyll"
categories: [jekyll,github-pages,liquid,json,lazyload,seo,performance,shakeleakedvibe]
tags: [random-posts,json-data,lazy-loading,jekyll-collections,blog-optimization]
description: "Learn how to build a responsive and SEO-friendly random post section in Jekyll using JSON data and lazy loading."
---

<p>One of the biggest challenges in building a random post section for static sites is keeping it lightweight, flexible, and SEO-friendly. If your randomization relies solely on client-side JavaScript, you may lose crawlability. On the other hand, hardcoding random posts can make your site feel repetitive. This article explores how to use JSON data and lazy loading together to build a smarter, faster, and fully responsive random post section in Jekyll.</p>

<h2>Why JSON-Based Random Posts Work Better</h2>
<p>When you separate content data (like titles, URLs, and images) into JSON, you get a more modular structure. Jekyll can build this data automatically using <code>_data</code> or collection exports. You can then pull a random subset each time the site builds or even on the client side, with minimal code.</p>

<ul>
  <li><strong>Modular content:</strong> JSON allows you to reuse post data anywhere on your site.</li>
  <li><strong>Faster builds:</strong> Pre-rendered data reduces Liquid loops on large sites.</li>
  <li><strong>Better SEO:</strong> You can still output structured HTML from static data.</li>
</ul>

<p>In other words, this approach combines the flexibility of data files with the performance of static HTML.</p>

<h2>Step 1: Generate a JSON Data File of All Posts</h2>
<p>Create a new file inside your Jekyll site at <code>_data/posts.json</code> or <code>_site/posts.json</code> depending on your workflow. You can populate it dynamically with Liquid as shown below.</p>

<pre><code>{% raw %}
[
  {% for post in site.posts %}
  {
    "title": "{{ post.title | escape }}",
    "url": "{{ post.url | relative_url }}",
    "image": "{{ post.image | default: '/photo/default.png' }}",
    "excerpt": "{{ post.excerpt | strip_html | strip_newlines | truncate: 120 }}"
  }{% unless forloop.last %},{% endunless %}
  {% endfor %}
]
{% endraw %}
</code></pre>

<p>This JSON file will serve as the database for your random post feature. Jekyll regenerates it during each build, ensuring it always reflects your latest content.</p>

<h2>Step 2: Display Random Posts Using Liquid</h2>
<p>You can then use Liquid filters to sample random posts directly from the JSON file:</p>

<pre><code>{% raw %}
{% assign posts_data = site.data.posts | sample: 6 %}
&lt;section class="random-grid"&gt;
  {% for post in posts_data %}
    &lt;a href="{{ post.url }}" class="random-item"&gt;
      &lt;img src="{{ post.image }}" alt="{{ post.title }}" loading="lazy"&gt;
      &lt;h4&gt;{{ post.title }}&lt;/h4&gt;
      &lt;p&gt;{{ post.excerpt }}&lt;/p&gt;
    &lt;/a&gt;
  {% endfor %}
&lt;/section&gt;
{% endraw %}
</code></pre>

<p>The <code>sample</code> filter ensures each build shows a different set of random posts. Since it’s static, Google can fully index and crawl all content variations over time.</p>

<h2>Step 3: Add Lazy Loading for Speed</h2>
<p>Lazy loading defers the loading of images until they are visible on the screen. This can dramatically improve your page load times, especially on mobile devices.</p>

<h3>Simple Lazy Load Example</h3>
<pre><code>&lt;img src="{{ post.image }}" alt="{{ post.title }}" loading="lazy" /&gt;</code></pre>

<p>This single attribute (<code>loading="lazy"</code>) is enough for modern browsers. You can also implement JavaScript fallback for older browsers if needed.</p>

<h3>Improving Cumulative Layout Shift (CLS)</h3>
<p>To avoid content jumping while images load, always specify width and height attributes, or use aspect-ratio containers:</p>

<pre><code>.random-item img {
  width: 100%;
  aspect-ratio: 16/9;
  object-fit: cover;
  border-radius: 10px;
}
</code></pre>

<p>This ensures that your layout remains stable as images appear, which improves user experience and your Core Web Vitals score — an important SEO factor.</p>

<h2>Step 4: Make It Fully Responsive</h2>
<p>Combine CSS Grid with flexible breakpoints so your random post section looks balanced on every screen.</p>

<pre><code>.random-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

.random-item {
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  transition: transform 0.2s ease;
}

.random-item:hover {
  transform: translateY(-4px);
}
</code></pre>

<p>These small touches — spacing, shadows, and hover effects — make your blog feel professional and cohesive without additional frameworks.</p>

<h2>Step 5: SEO and Crawlability Best Practices</h2>
<p>Because Jekyll generates static HTML, your random posts are already crawlable. Still, there are a few tricks to make sure Google understands them correctly.</p>

<ul>
  <li>Use <code>alt</code> attributes and descriptive filenames for images.</li>
  <li>Use semantic tags such as <code>&lt;section&gt;</code> and <code>&lt;article&gt;</code>.</li>
  <li>Add internal linking relevance by grouping related tags or categories.</li>
  <li>Include JSON-LD schema markup for improved understanding.</li>
</ul>

<h3>Example: Random Post Schema</h3>
<pre><code>&lt;script type="application/ld+json"&gt;
{
  "@context": "https://schema.org",
  "@type": "ItemList",
  "itemListElement": [
    {% raw %}{% for post in posts_data %}
    {
      "@type": "ListItem",
      "position": {{ forloop.index }},
      "url": "{{ post.url | absolute_url }}"
    }{% if forloop.last == false %},{% endif %}
    {% endfor %}{% endraw %}
  ]
}
&lt;/script&gt;
</code></pre>

<p>This structured data helps search engines treat your random post grid as an organized set of related articles rather than unrelated links.</p>

<h2>Step 6: Optional – Random Posts via JSON Fetch</h2>
<p>If you want more dynamic randomization (e.g., different posts on each page load), you can use lightweight client-side JavaScript to fetch the same JSON file and shuffle it in the browser. However, you should always output fallback HTML in the Liquid template to maintain SEO value.</p>

<pre><code>&lt;script&gt;
fetch('/posts.json')
  .then(response =&gt; response.json())
  .then(data =&gt; {
    const shuffled = data.sort(() =&gt; 0.5 - Math.random()).slice(0, 5);
    const container = document.querySelector('.random-grid');
    shuffled.forEach(post =&gt; {
      const item = document.createElement('a');
      item.href = post.url;
      item.className = 'random-item';
      item.innerHTML = `
        &lt;img src="${post.image}" alt="${post.title}" loading="lazy"&gt;
        &lt;h4&gt;${post.title}&lt;/h4&gt;
      `;
      container.appendChild(item);
    });
  });
&lt;/script&gt;
</code></pre>

<p>This hybrid approach ensures that your static pages remain SEO-friendly while adding dynamic user experience on reload.</p>

<h2>Performance Metrics You Should Watch</h2>
<table>
  <tr><th>Metric</th><th>Goal</th><th>Improvement Method</th></tr>
  <tr><td>Largest Contentful Paint (LCP)</td><td>&lt; 2.5s</td><td>Use lazy loading, optimize images</td></tr>
  <tr><td>First Input Delay (FID)</td><td>&lt; 100ms</td><td>Minimize JS execution</td></tr>
  <tr><td>Cumulative Layout Shift (CLS)</td><td>&lt; 0.1</td><td>Use fixed image aspect ratios</td></tr>
</table>

<h2>Final Thoughts</h2>
<p>By combining JSON data, lazy loading, and responsive design, your Jekyll random post section becomes both elegant and efficient. You reduce redundant code, enhance mobile usability, and maintain a high SEO value through pre-rendered, crawlable HTML. This blend of data-driven structure and minimalistic design is exactly what modern static blogs need to stay fast, smart, and discoverable.</p>

<p>In short, random posts don’t have to be chaotic — with the right setup, they can become a strategic part of your content ecosystem.</p>
