---
layout: post162
title: "Monitoring Jekyll Site Health with Cloudflare Analytics and Ruby Gems"
categories: [convexseo,monitoring, jekyll, cloudflare]
tags: [site monitoring, jekyll health, cloudflare metrics, ruby monitoring gems, uptime monitoring, performance alerts, error tracking, analytics dashboards, automated reports, site reliability]
description: "Build a comprehensive monitoring system for your Jekyll site using Cloudflare Analytics data and specialized Ruby gems to track performance, uptime, and user experience."
---
<p>Your Jekyll site seems to be running fine, but you're flying blind. You don't know if it's actually available to visitors worldwide, how fast it loads in different regions, or when errors occur. This lack of visibility means problems go undetected until users complain. The frustration of discovering issues too late can damage your reputation and search rankings. You need a proactive monitoring system that leverages Cloudflare's global network and Ruby's automation capabilities.</p>

<div class="toc">
    <h2>In This Article</h2>
    <ul>
        <li><a href="#monitoring-architecture">Building a Monitoring Architecture for Static Sites</a></li>
        <li><a href="#cloudflare-metrics">Essential Cloudflare Metrics for Jekyll Sites</a></li>
        <li><a href="#ruby-monitoring-gems">Ruby Gems for Enhanced Monitoring</a></li>
        <li><a href="#automated-alerts">Setting Up Automated Alerts and Notifications</a></li>
        <li><a href="#performance-dashboards">Creating Performance Dashboards</a></li>
        <li><a href="#error-tracking">Error Tracking and Diagnostics</a></li>
        <li><a href="#maintenance-automation">Automated Maintenance and Recovery</a></li>
    </ul>
</div>

<h2 id="monitoring-architecture">Building a Monitoring Architecture for Static Sites</h2>
<p>Monitoring a Jekyll site requires a different approach than dynamic applications. Since there's no server-side processing to monitor, you focus on: (1) Content delivery performance, (2) Uptime and availability, (3) User experience metrics, and (4) Third-party service dependencies. Cloudflare provides the foundation with its global vantage points, while Ruby gems add automation and integration capabilities.</p>
<p>The architecture should be multi-layered: real-time monitoring (checking if the site is up), performance monitoring (how fast it loads), business monitoring (are conversions happening), and predictive monitoring (trend analysis). Each layer uses different Cloudflare data sources and Ruby tools. The goal is to detect issues before users do, and to have automated responses for common problems.</p>

<h3 id="monitoring-layers">Four-Layer Monitoring Architecture</h3>
<table>
<thead>
<tr>
<th>Layer</th>
<th>What It Monitors</th>
<th>Cloudflare Data Source</th>
<th>Ruby Tools</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Infrastructure</strong></td>
<td>DNS, SSL, Network</td>
<td>Health Checks, SSL Analytics</td>
<td>net-http, ssl-certificate gems</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Load times, Core Web Vitals</td>
<td>Speed Analytics, Real User Monitoring</td>
<td>benchmark, ruby-prof gems</td>
</tr>
<tr>
<td><strong>Content</strong></td>
<td>Broken links, missing assets</td>
<td>Cache Analytics, Error Analytics</td>
<td>nokogiri, link-checker gems</td>
</tr>
<tr>
<td><strong>Business</strong></td>
<td>Traffic trends, conversions</td>
<td>Web Analytics, GraphQL Analytics</td>
<td>chartkick, gruff gems</td>
</tr>
</tbody>
</table>

<h2 id="cloudflare-metrics">Essential Cloudflare Metrics for Jekyll Sites</h2>
<p>Cloudflare provides dozens of metrics. Focus on these key ones for Jekyll:</p>

<h3>1. Cache Hit Ratio</h3>
<p>Measures how often Cloudflare serves cached content vs fetching from origin. Ideal: >90%.</p>
<pre><code># Fetch via API
def cache_hit_ratio
  response = cf_api_get("zones/#{zone_id}/analytics/dashboard", {
    since: '-1440', # 24 hours
    until: '0'
  })
  
  totals = response['result']['totals']
  cached = totals['requests']['cached']
  total = totals['requests']['all']
  
  (cached.to_f / total * 100).round(2)
end</code></pre>

<h3>2. Origin Response Time</h3>
<p>How long GitHub Pages takes to respond. Should be < 200ms.</p>
<pre><code>def origin_response_time
  data = cf_api_get("zones/#{zone_id}/healthchecks/analytics")
  data['result']['origin_response_time']['p95'] # 95th percentile
end</code></pre>

<h3>3. Error Rate (5xx Status Codes)</h3>
<p>Monitor for GitHub Pages outages or misconfigurations.</p>
<pre><code>def error_rate
  data = cf_api_get("zones/#{zone_id}/http/analytics", {
    dimensions: ['statusCode'],
    filters: 'statusCode ge 500'
  })
  
  error_requests = data['result'].sum { |r| r['metrics']['requests'] }
  total_requests = get_total_requests()
  
  (error_requests.to_f / total_requests * 100).round(2)
end</code></pre>

<h3>4. Core Web Vitals via Browser Insights</h3>
<p>Real user experience metrics:</p>
<pre><code>def core_web_vitals
  cf_api_get("zones/#{zone_id}/speed/api/insights", {
    metrics: ['lcp', 'fid', 'cls']
  })
end</code></pre>

<h2 id="ruby-monitoring-gems">Ruby Gems for Enhanced Monitoring</h2>
<p>Extend Cloudflare's capabilities with these gems:</p>

<h3>1. cloudflare-rails</h3>
<p>Though designed for Rails, adapt it for Jekyll monitoring:</p>
<pre><code>gem 'cloudflare-rails'

# Configure for monitoring
Cloudflare::Rails.configure do |config|
  config.ips = []  # Don't trust Cloudflare IPs for Jekyll
  config.logger = Logger.new('log/cloudflare.log')
end

# Use its middleware to log requests
use Cloudflare::Rails::Middleware</code></pre>

<h3>2. health_check</h3>
<p>Create health check endpoints:</p>
<pre><code>gem 'health_check'

# Create a health check route
get '/health' do
  {
    status: 'healthy',
    timestamp: Time.now.iso8601,
    checks: {
      cloudflare: check_cloudflare_connection,
      github_pages: check_github_pages,
      dns: check_dns_resolution
    }
  }.to_json
end</code></pre>

<h3>3. whenever + clockwork</h3>
<p>Schedule monitoring tasks:</p>
<pre><code>gem 'whenever'

# config/schedule.rb
every 5.minutes do
  runner "CloudflareMonitor.check_metrics"
end

every 1.hour do
  runner "PerformanceAuditor.run_full_check"
end</code></pre>

<h3>4. slack-notifier</h3>
<p>Send alerts to Slack:</p>
<pre><code>gem 'slack-notifier'

notifier = Slack::Notifier.new(
  ENV['SLACK_WEBHOOK_URL'],
  channel: '#site-alerts',
  username: 'Jekyll Monitor'
)

def send_alert(message, level: :warning)
  notifier.post(
    text: message,
    icon_emoji: level == :critical ? ':fire:' : ':warning:'
  )
end</code></pre>

<h2 id="automated-alerts">Setting Up Automated Alerts and Notifications</h2>
<p>Create smart alerts that trigger only when necessary:</p>

<pre><code># lib/monitoring/alert_manager.rb
class AlertManager
  ALERT_THRESHOLDS = {
    cache_hit_ratio: { warn: 80, critical: 60 },
    origin_response_time: { warn: 500, critical: 1000 }, # ms
    error_rate: { warn: 1, critical: 5 }, # percentage
    uptime: { warn: 99.5, critical: 99.0 } # percentage
  }
  
  def self.check_and_alert
    metrics = CloudflareMetrics.fetch
    
    ALERT_THRESHOLDS.each do |metric, thresholds|
      value = metrics[metric]
      
      if value >= thresholds[:critical]
        send_alert("#{metric.to_s.upcase} CRITICAL: #{value}", :critical)
      elsif value >= thresholds[:warn]
        send_alert("#{metric.to_s.upcase} Warning: #{value}", :warning)
      end
    end
  end
  
  def self.send_alert(message, level)
    # Send to multiple channels
    SlackNotifier.send(message, level)
    EmailNotifier.send(message, level) if level == :critical
    
    # Log to file
    File.open('log/alerts.log', 'a') do |f|
      f.puts "[#{Time.now}] #{level.upcase}: #{message}"
    end
  end
end

# Run every 15 minutes
AlertManager.check_and_alert</code></pre>

<p>Add alert deduplication to prevent spam:</p>
<pre><code>def should_alert?(metric, value, level)
  last_alert = $redis.get("last_alert:#{metric}:#{level}")
  
  # Don't alert if we alerted in the last hour for same issue
  if last_alert && Time.now - Time.parse(last_alert) < 3600
    return false
  end
  
  $redis.setex("last_alert:#{metric}:#{level}", 3600, Time.now.iso8601)
  true
end</code></pre>

<h2 id="performance-dashboards">Creating Performance Dashboards</h2>
<p>Build internal dashboards using Ruby web frameworks:</p>

<h3>Option 1: Sinatra Dashboard</h3>
<pre><code>gem 'sinatra'
gem 'chartkick'

# app.rb
require 'sinatra'
require 'chartkick'

get '/dashboard' do
  @metrics = {
    cache_hit_ratio: CloudflareAPI.cache_hit_ratio,
    response_times: CloudflareAPI.response_time_history,
    traffic: CloudflareAPI.traffic_by_country
  }
  
  erb :dashboard
end

# views/dashboard.erb
<%= line_chart @metrics[:traffic] %>
<%= pie_chart @metrics[:cache_hit_ratio] %>
<%= geo_chart @metrics[:traffic_by_country] %></code></pre>

<h3>Option 2: Static Dashboard Generated by Jekyll</h3>
<pre><code># _plugins/metrics_generator.rb
module Jekyll
  class MetricsGenerator < Generator
    def generate(site)
      # Fetch metrics
      metrics = fetch_cloudflare_metrics
      
      # Create data file
      site.data['metrics'] = metrics
      
      # Generate dashboard page
      page = PageWithoutAFile.new(site, __dir__, '', 'dashboard.md')
      page.content = generate_dashboard_content(metrics)
      page.data = {
        'layout' => 'dashboard',
        'title' => 'Site Metrics Dashboard',
        'permalink' => '/internal/dashboard/'
      }
      site.pages   page
    end
  end
end</code></pre>

<h3>Option 3: Grafana + Ruby Exporter</h3>
<p>Use `prometheus-client` gem to export metrics to Grafana:</p>
<pre><code>gem 'prometheus-client'

# Configure exporter
Prometheus::Client.configure do |config|
  config.logger = Logger.new('log/prometheus.log')
end

# Define metrics
CACHE_HIT_RATIO = Prometheus::Client::Gauge.new(
  :cloudflare_cache_hit_ratio,
  'Cache hit ratio percentage'
)

# Update metrics
Thread.new do
  loop do
    CACHE_HIT_RATIO.set(CloudflareAPI.cache_hit_ratio)
    sleep 60
  end
end

# Expose metrics endpoint
get '/metrics' do
  Prometheus::Client::Formats::Text.marshal(Prometheus::Client.registry)
end</code></pre>

<h2 id="error-tracking">Error Tracking and Diagnostics</h2>
<p>Monitor for specific error patterns:</p>

<pre><code># lib/monitoring/error_tracker.rb
class ErrorTracker
  def self.track_cloudflare_errors
    errors = cf_api_get("zones/#{zone_id}/analytics/events/errors", {
      since: '-60',  # Last hour
      dimensions: ['clientRequestPath', 'originResponseStatus']
    })
    
    errors['result'].each do |error|
      next if whitelisted_error?(error)
      
      log_error(error)
      alert_if_critical(error)
      attempt_auto_recovery(error)
    end
  end
  
  def self.whitelisted_error?(error)
    # Ignore 404s on obviously wrong URLs
    path = error['dimensions'][0]
    status = error['dimensions'][1]
    
    return true if status == '404' && path.include?('wp-')
    return true if status == '403' && path.include?('.env')
    false
  end
  
  def self.attempt_auto_recovery(error)
    case error['dimensions'][1]
    when '502', '503', '504'
      # GitHub Pages might be down, purge cache
      CloudflareAPI.purge_cache_for_path(error['dimensions'][0])
    when '404'
      # Check if page should exist
      if page_should_exist?(error['dimensions'][0])
        trigger_build_to_regenerate_page
      end
    end
  end
end</code></pre>

<h2 id="maintenance-automation">Automated Maintenance and Recovery</h2>
<p>Automate responses to common issues:</p>

<pre><code># lib/maintenance/auto_recovery.rb
class AutoRecovery
  def self.run
    # Check for GitHub Pages build failures
    if build_failing_for_more_than?(30.minutes)
      trigger_manual_build
      send_alert("Build was failing, triggered manual rebuild", :info)
    end
    
    # Check for DNS propagation issues
    if dns_propagation_delayed?
      increase_cloudflare_dns_ttl
      send_alert("Increased DNS TTL due to propagation delays", :warning)
    end
    
    # Check for excessive cache misses
    if cache_hit_ratio < 70
      warm_cache_for_top_pages
      send_alert("Cache hit ratio low, warming cache", :warning)
    end
    
    # Weekly maintenance tasks
    if Time.now.wday == 0 && Time.now.hour == 2  # Sunday 2 AM
      run_link_check
      compress_old_logs
      backup_analytics_data
    end
  end
  
  def self.trigger_manual_build
    # Trigger GitHub Actions workflow via API
    HTTParty.post(
      "https://api.github.com/repos/#{repo}/dispatches",
      headers: { 'Authorization' => "token #{ENV['GITHUB_TOKEN']}" },
      body: { event_type: 'manual-build' }.to_json
    )
  end
end

# Run every hour
AutoRecovery.run</code></pre>

<p>Implement a comprehensive monitoring system this week. Start with basic uptime checks and cache monitoring. Gradually add performance tracking and automated alerts. Within a month, you'll have complete visibility into your Jekyll site's health and automated responses for common issues, ensuring maximum reliability for your visitors.</p>