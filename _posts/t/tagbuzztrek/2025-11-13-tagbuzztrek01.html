---
layout: post02
title: "Can Durable Objects Add Real Stateful Logic to GitHub Pages"
categories: [github-pages, cloudflare, edge-computing,tagbuzztrek]
tags: [github, github-pages, cloudflare, durable-objects, workers, kv, sessions, consistency, realtime, routing, api, state, edge]
description: "Learn how Durable Objects give GitHub Pages real stateful capabilities including sessions and consistent counters at the edge"
---

<p>Cloudflare Durable Objects allow GitHub Pages users to expand a static website into a platform capable of consistent state, sessions, and coordinated logic. Many developers question how a static site like GitHub Pages can support real-time functions or data accuracy, and Durable Objects provide the missing building block that makes global coordination possible at the edge.</p>

<p>Setelah memahami KV Storage pada artikel sebelumnya, bagian ini menggali lebih dalam bagaimana Durable Objects memberikan konsistensi data, kemampuan multi-step operations, dan interaksi real-time yang stabil bahkan untuk situs yang di-host di GitHub Pages. Untuk memudahkan navigasi, daftar isi berikut merangkum seluruh pembahasan.</p>

<h2>Mengenal Struktur Stateful Edge untuk GitHub Pages</h2>

<ul>
  <li><a href="#do-basics">What Makes Durable Objects Different from KV Storage</a></li>
  <li><a href="#why-needed">Why GitHub Pages Needs Durable Objects</a></li>
  <li><a href="#setup">Setting Up Durable Objects for Your Worker</a></li>
  <li><a href="#consistent-counter">Building a Consistent Global Counter</a></li>
  <li><a href="#session-system">Implementing a Lightweight Session System</a></li>
  <li><a href="#realtime">Adding Real-Time Interactions to a Static Site</a></li>
  <li><a href="#coordination">Cross-Region Coordination and Scaling</a></li>
  <li><a href="#case-study">Case Study Using Durable Objects with GitHub Pages</a></li>
  <li><a href="#future">Future Enhancements with DO and Worker AI</a></li>
</ul>

<h2 id="do-basics">What Makes Durable Objects Different from KV Storage</h2>

<p>Durable Objects differ from KV because they act as a single authoritative instance for any given key. While KV provides global distributed storage optimized for reads, Durable Objects provide strict consistency and deterministic behavior for operations such as counters, queues, sessions, chat rooms, or workflows.</p>

<p>When a Durable Object is accessed, Cloudflare ensures that only one instance handles requests for that specific ID. This guarantees atomic updates, making it suitable for tasks such as real-time editing, consistent increments, or multi-step transactions. KV Storage cannot guarantee immediate consistency, but Durable Objects do, making them ideal for features that require accuracy.</p>

<p>GitHub Pages does not have backend capabilities, but when paired with Durable Objects, it gains the ability to store logic that behaves like a small server. The code runs at the edge, is low-latency, and works seamlessly with Workers and KV, expanding what a static site can do.</p>

<h2 id="why-needed">Why GitHub Pages Needs Durable Objects</h2>

<p>GitHub Pages users often want features that require synchronized state: visitor counters with exact accuracy, simple chat components, multiplayer interactions, form processing with validation, or real-time dashboards. Without server-side logic, this is impossible with GitHub Pages alone.</p>

<p>Durable Objects solve several limitations commonly found in static hosting:</p>

<ul>
  <li><strong>Consistent updates</strong> for multi-user interactions.</li>
  <li><strong>Atomic sequences</strong> for processes that require strict order.</li>
  <li><strong>Per-user or per-session storage</strong> for authentication-lite use cases.</li>
  <li><strong>Long-lived state</strong> maintained across requests.</li>
  <li><strong>Message passing</strong> for real-time interactions.</li>
</ul>

<p>These features bridge the gap between static hosting and dynamic backends. Durable Objects essentially act like mini edge servers attached to a static site, eliminating the need for servers, databases, or complex architectures.</p>

<h2 id="setup">Setting Up Durable Objects for Your Worker</h2>

<p>Setting up Durable Objects involves defining a class and binding it in the Worker configuration. Once defined, Cloudflare automatically manages the lifecycle, routing, and persistence for each object. Developers only need to write the logic for the object itself.</p>

<p>Berikut langkah mendasar untuk mengaktifkannya:</p>

<ol>
  <li>Open the Cloudflare Dashboard and choose <strong>Workers & Pages</strong>.</li>
  <li>Create or edit your Worker.</li>
  <li>Open <strong>Durable Objects Bindings</strong> in the settings panel.</li>
  <li>Add a new binding and specify a name such as <code>SESSION_STORE</code>.</li>
  <li>Define your Durable Object class in your Worker script.</li>
</ol>

<p>Contoh struktur paling sederhana terlihat seperti ini:</p>

<pre><code>export class Counter {
  constructor(state, env) {
    this.state = state;
  }

  async fetch(request) {
    let count = await this.state.storage.get("count") || 0;
    count++;
    await this.state.storage.put("count", count);
    return new Response(JSON.stringify({ total: count }));
  }
}
</code></pre>

<p>Durable Objects use per-instance storage that persists between requests. Each instance can store structured data and respond to requests with custom logic. GitHub Pages users can interact with these objects through simple API calls from their static JavaScript.</p>

<h2 id="consistent-counter">Building a Consistent Global Counter</h2>

<p>One of the clearest demonstrations of Durable Objects is a strictly consistent counter. Unlike KV Storage, which is eventually consistent, a Durable Object ensures that increments are never duplicated or lost even if multiple visitors trigger the function simultaneously.</p>

<p>Here is a more complete implementation:</p>

<pre><code>export class GlobalCounter {
  constructor(state, env) {
    this.state = state;
  }

  async fetch(request) {
    const value = await this.state.storage.get("value") || 0;
    const updated = value + 1;
    await this.state.storage.put("value", updated);

    return new Response(JSON.stringify({ value: updated }), {
      headers: { "content-type": "application/json" }
    });
  }
}
</code></pre>

<p>This pattern works well for:</p>

<ul>
  <li>Accurate page view counters.</li>
  <li>Total site-wide visitor counts.</li>
  <li>Limited access counters for downloads or protected resources.</li>
</ul>

<p>GitHub Pages visitors will see updated values instantly. Integrating this logic into a static blog or landing page is straightforward using a client-side fetch call that displays the returned number.</p>

<h2 id="session-system">Implementing a Lightweight Session System</h2>

<p>Durable Objects are effective for creating small session systems where each user or device receives a unique session object. This can store until visitor preferences, login-lite identifiers, timestamps, or even small progress indicators.</p>

<p>A simple session Durable Object may look like this:</p>

<pre><code>export class SessionObject {
  constructor(state, env) {
    this.state = state;
  }

  async fetch(request) {
    let session = await this.state.storage.get("session") || {};
    session.lastVisit = new Date().toISOString();
    await this.state.storage.put("session", session);

    return new Response(JSON.stringify(session), {
      headers: { "content-type": "application/json" }
    });
  }
}
</code></pre>

<p>This enables GitHub Pages to offer features like remembering the last visit, storing UI preferences, saving progress, or tracking anonymous user journeys without requiring database servers. When paired with KV, sessions become powerful yet minimal.</p>

<h2 id="realtime">Adding Real-Time Interactions to a Static Site</h2>

<p>Real-time functionality is one of the strongest advantages of Durable Objects. They support WebSockets, enabling live interactions directly from GitHub Pages such as:</p>

<ul>
  <li>Real-time chat rooms for documentation support.</li>
  <li>Live dashboards for analytics or counters.</li>
  <li>Shared editing sessions for collaborative notes.</li>
  <li>Instant alerts or notifications.</li>
</ul>

<p>Here is a minimal WebSocket Durable Object handler:</p>

<pre><code>export class ChatRoom {
  constructor(state) {
    this.state = state;
    this.connections = [];
  }

  async fetch(request) {
    const [client, server] = Object.values(new WebSocketPair());
    this.connections.push(server);
    server.accept();

    server.addEventListener("message", msg => {
      this.broadcast(msg.data);
    });

    return new Response(null, { status: 101, webSocket: client });
  }

  broadcast(message) {
    for (const conn of this.connections) {
      conn.send(message);
    }
  }
}
</code></pre>

<p>Visitors connecting from a static GitHub Pages site can join the chat room instantly. The Durable Object enforces strict ordering and consistency, guaranteeing that messages are processed in the exact order they are received.</p>

<h2 id="coordination">Cross-Region Coordination and Scaling</h2>

<p>Durable Objects run on Cloudflare’s global network but maintain a single instance per ID. Cloudflare automatically places the object near the geographic location that receives the most traffic. Requests from other regions are routed efficiently, ensuring minimal latency and guaranteed coordination.</p>

<p>This architecture offers predictable scaling and avoids the "split-brain" scenarios common with eventually consistent systems. For GitHub Pages projects that require message queues, locks, or flows with dependencies, Durable Objects provide the right tool.</p>

<h2 id="case-study">Case Study Using Durable Objects with GitHub Pages</h2>

<p>A developer created an interactive documentation website hosted on GitHub Pages. They wanted a real-time support chat without using third-party platforms. By using Durable Objects, they built a chat room that handled hundreds of simultaneous users, stored past messages, and synchronized notifications.</p>

<p>The front-end remained pure static HTML and JavaScript hosted on GitHub Pages. The Durable Object handled every message, timestamp, and storage event. Combined with KV Storage for history archival, the system performed efficiently under high global load.</p>

<p>This example demonstrates how Durable Objects enable practical, real-world dynamic behavior for static hosting environments that were traditionally limited.</p>

<h2 id="future">Future Enhancements with DO and Worker AI</h2>

<p>Durable Objects continue to evolve and integrate with Cloudflare’s new Worker AI platform. Future enhancements may include:</p>

<ul>
  <li>AI-assisted chat bots running within the same Durable Object instance.</li>
  <li>Intelligent caching and prediction for GitHub Pages visitors.</li>
  <li>Local inference models for personalization.</li>
  <li>Improved consistency mechanisms for high-traffic DO applications.</li>
</ul>

<p>On the next article, we will explore how Workers AI combined with Durable Objects can give GitHub Pages advanced personalization, local inference, and dynamic content generation entirely at the edge.</p>
